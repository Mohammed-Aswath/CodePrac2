"""
Question Management Service Module
Handles role-aware question creation, retrieval, and management
"""

from models import QuestionModel, TopicModel, BatchModel, DepartmentModel, CollegeModel
from agent_wrappers import generate_hidden_testcases
from utils import error_response, success_response, audit_log
from flask import jsonify


class QuestionService:
    """Centralized service for question management with role-based access control."""
    
    @staticmethod
    def validate_question_data(data):
        """
        Validate required question fields for creation.
        
        Required fields (per CodePrac2.0 specification):
        - title: Question title
        - description: Question description
        - sample_input: Sample input for testing
        - sample_output: Expected sample output
        
        Note: language field is only needed when students attempt questions,
              not when creating questions. Hidden testcases are auto-generated by AI.
        
        Args:
            data (dict): Question data to validate
            
        Returns:
            tuple: (is_valid, error_message)
        """
        required_fields = [
            "title", "description", "sample_input", "sample_output"
        ]
        
        for field in required_fields:
            if not data.get(field) or not str(data.get(field)).strip():
                return False, f"Missing required field: {field}"
        
        if not data.get("title") or len(str(data.get("title")).strip()) < 3:
            return False, "Title must be at least 3 characters"
        
        if not data.get("description") or len(str(data.get("description")).strip()) < 10:
            return False, "Description must be at least 10 characters"
        
        return True, None
    
    @staticmethod
    def create_question_by_admin(request_user, data):
        """
        Create question as Super Admin (can choose any college/department/batch).
        
        Args:
            request_user (dict): Authenticated user data
            data (dict): Question data
            
        Returns:
            tuple: (response, status_code)
        """
        # Validate required fields
        is_valid, error_msg = QuestionService.validate_question_data(data)
        if not is_valid:
            return error_response("INVALID_INPUT", error_msg, status_code=400)
        
        # Super admin must specify college, department, and batch
        if not data.get("college_id") or not data.get("department_id") or not data.get("batch_id"):
            return error_response("INVALID_INPUT", "Super Admin must specify college_id, department_id, and batch_id", status_code=400)
        
        college_id = data.get("college_id")
        dept_id = data.get("department_id")
        batch_id = data.get("batch_id")
        
        # Verify college exists and is not disabled
        college = CollegeModel().get(college_id)
        if not college:
            return error_response("NOT_FOUND", "College not found", status_code=404)
        if college.get("is_disabled", False):
            return error_response("FORBIDDEN", "College is disabled", status_code=403)
        
        # Verify department exists, belongs to college, and is not disabled
        dept = DepartmentModel().get(dept_id)
        if not dept or dept.get("college_id") != college_id:
            return error_response("NOT_FOUND", "Department not found in this college", status_code=404)
        if dept.get("is_disabled", False):
            return error_response("FORBIDDEN", "Department is disabled", status_code=403)
        
        # Verify batch exists, belongs to department, and is not disabled
        batch = BatchModel().get(batch_id)
        if not batch or batch.get("department_id") != dept_id:
            return error_response("NOT_FOUND", "Batch not found in this department", status_code=404)
        if batch.get("is_disabled", False):
            return error_response("FORBIDDEN", "Batch is disabled", status_code=403)
        
        # Verify topic belongs to department (if provided)
        if data.get("topic_id"):
            topic = TopicModel().get(data.get("topic_id"))
            if not topic or topic.get("department_id") != dept_id:
                return error_response("NOT_FOUND", "Topic not found in this department", status_code=404)
        
        return QuestionService._save_question(
            college_id, dept_id, batch_id,
            request_user.get("uid"), data
        )
    
    @staticmethod
    def create_question_by_college(request_user, data):
        """
        Create question as College Admin (can only choose departments/batches within their college).
        
        Args:
            request_user (dict): Authenticated user data
            data (dict): Question data
            
        Returns:
            tuple: (response, status_code)
        """
        is_valid, error_msg = QuestionService.validate_question_data(data)
        if not is_valid:
            return error_response("INVALID_INPUT", error_msg, status_code=400)
        
        college_id = request_user.get("college_id")
        
        # College admin must specify department and batch
        if not data.get("department_id") or not data.get("batch_id"):
            return error_response("INVALID_INPUT", "Must specify department_id and batch_id", status_code=400)
        
        dept_id = data.get("department_id")
        batch_id = data.get("batch_id")
        
        # Verify department exists, belongs to this college, and is not disabled
        dept = DepartmentModel().get(dept_id)
        if not dept or dept.get("college_id") != college_id:
            return error_response("NOT_FOUND", "Department not found in your college", status_code=404)
        if dept.get("is_disabled", False):
            return error_response("FORBIDDEN", "Department is disabled", status_code=403)
        
        # Verify batch exists, belongs to department, and is not disabled
        batch = BatchModel().get(batch_id)
        if not batch or batch.get("department_id") != dept_id:
            return error_response("NOT_FOUND", "Batch not found in this department", status_code=404)
        if batch.get("is_disabled", False):
            return error_response("FORBIDDEN", "Batch is disabled", status_code=403)
        
        # Verify topic belongs to department (if provided)
        if data.get("topic_id"):
            topic = TopicModel().get(data.get("topic_id"))
            if not topic or topic.get("department_id") != dept_id:
                return error_response("NOT_FOUND", "Topic not found in this department", status_code=404)
        
        return QuestionService._save_question(
            college_id, dept_id, batch_id,
            request_user.get("uid"), data
        )
    
    @staticmethod
    def create_question_by_department(request_user, data):
        """
        Create question as Department Admin (can only choose batches within their department).
        
        Args:
            request_user (dict): Authenticated user data
            data (dict): Question data
            
        Returns:
            tuple: (response, status_code)
        """
        is_valid, error_msg = QuestionService.validate_question_data(data)
        if not is_valid:
            return error_response("INVALID_INPUT", error_msg, status_code=400)
        
        dept_id = request_user.get("department_id")
        college_id = request_user.get("college_id")
        
        # Department admin must specify batch
        if not data.get("batch_id"):
            return error_response("INVALID_INPUT", "Must specify batch_id", status_code=400)
        
        batch_id = data.get("batch_id")
        
        # Verify batch exists, belongs to this department, and is not disabled
        batch = BatchModel().get(batch_id)
        if not batch or batch.get("department_id") != dept_id:
            return error_response("NOT_FOUND", "Batch not found in your department", status_code=404)
        if batch.get("is_disabled", False):
            return error_response("FORBIDDEN", "Batch is disabled", status_code=403)
        
        # Verify topic belongs to this department (if provided)
        if data.get("topic_id"):
            topic = TopicModel().get(data.get("topic_id"))
            if not topic or topic.get("department_id") != dept_id:
                return error_response("NOT_FOUND", "Topic not found in your department", status_code=404)
        
        return QuestionService._save_question(
            college_id, dept_id, batch_id,
            request_user.get("uid"), data
        )
    
    @staticmethod
    def create_question_by_batch(request_user, data):
        """
        Create question as Batch Admin (can only create questions for their batch).
        
        Args:
            request_user (dict): Authenticated user data
            data (dict): Question data
            
        Returns:
            tuple: (response, status_code)
        """
        is_valid, error_msg = QuestionService.validate_question_data(data)
        if not is_valid:
            return error_response("INVALID_INPUT", error_msg, status_code=400)
        
        batch_id = request_user.get("batch_id")
        dept_id = request_user.get("department_id")
        college_id = request_user.get("college_id")
        
        if not batch_id:
            return error_response("FORBIDDEN", "Batch information not found in user profile", status_code=400)
        
        # Verify batch exists and is not disabled
        batch = BatchModel().get(batch_id)
        if not batch:
            return error_response("NOT_FOUND", "Batch not found", status_code=404)
        if batch.get("is_disabled", False):
            return error_response("FORBIDDEN", "Batch is disabled", status_code=403)
        
        # Verify topic belongs to department (if provided)
        if data.get("topic_id"):
            topic = TopicModel().get(data.get("topic_id"))
            if not topic or topic.get("department_id") != dept_id:
                return error_response("NOT_FOUND", "Topic not found in your department", status_code=404)
        
        return QuestionService._save_question(
            college_id, dept_id, batch_id,
            request_user.get("uid"), data
        )
    
    @staticmethod
    def _save_question(college_id, dept_id, batch_id, user_uid, data):
        """
        Internal method to save question to database and generate test cases.
        
        Args:
            college_id (str): College ID
            dept_id (str): Department ID
            batch_id (str): Batch ID
            user_uid (str): User ID
            data (dict): Question data
            
        Returns:
            tuple: (response, status_code)
        """
        try:
            # Generate hidden test cases using AI
            hidden_testcases = generate_hidden_testcases(
                data.get("description", ""),
                data.get("sample_input", ""),
                data.get("sample_output", "")
            )
            
            # Build question data
            question_data = {
                "college_id": college_id,
                "department_id": dept_id,
                "batch_id": batch_id,
                "topic_id": data.get("topic_id", ""),
                "title": data.get("title", "").strip(),
                "description": data.get("description", "").strip(),
                "language": data.get("language", ""),
                "sample_input": data.get("sample_input", "").strip(),
                "sample_output": data.get("sample_output", "").strip(),
                "open_testcases": [{
                    "input": data.get("sample_input", "").strip(),
                    "expected_output": data.get("sample_output", "").strip()
                }],
                "hidden_testcases": hidden_testcases,
                "difficulty": data.get("difficulty", "Medium"),
                "is_active": True
            }
            
            # Save to database
            question_id = QuestionModel().create(question_data)
            
            # Log audit
            audit_log(
                user_uid, "create_question", "question", question_id,
                {"title": question_data["title"], "batch_id": batch_id}
            )
            
            return success_response({
                "question_id": question_id,
                "hidden_testcases_count": len(hidden_testcases),
                "title": question_data["title"]
            }, "Question created successfully", status_code=201)
        
        except Exception as e:
            return error_response("CREATE_ERROR", f"Failed to create question: {str(e)}", status_code=500)
    
    @staticmethod
    def get_questions_by_role(request_user):
        """
        Get questions filtered by user role.
        
        Args:
            request_user (dict): Authenticated user data
            
        Returns:
            list: Questions accessible to user
        """
        role = request_user.get("role")
        filters = {}
        
        if role == "admin":
            # Super admin sees all questions
            filters = {}
        elif role == "college":
            # College admin sees questions in their college
            filters = {"college_id": request_user.get("college_id")}
        elif role == "department":
            # Department admin sees questions in their department
            filters = {"department_id": request_user.get("department_id")}
        elif role == "batch":
            # Batch admin sees questions in their batch
            filters = {"batch_id": request_user.get("batch_id")}
        else:
            filters = {}
        
        try:
            questions = QuestionModel().query(**filters)
            return questions if questions else []
        except Exception:
            return []
    
    @staticmethod
    @staticmethod
    def delete_question(request_user, question_id):
        """
        Delete a question with role-based access control.
        
        Args:
            request_user (dict): Authenticated user data
            question_id (str): Question ID to delete
            
        Returns:
            tuple: (response, status_code)
        """
        question = QuestionModel().get(question_id)
        if not question:
            return error_response("NOT_FOUND", "Question not found", status_code=404)
        
        role = request_user.get("role")
        user_id = request_user.get("uid")
        
        # Check authorization based on role
        if role == "admin":
            # Super admin can delete any question
            pass
        elif role == "college":
            # College admin can only delete questions in their college
            if question.get("college_id") != request_user.get("college_id"):
                return error_response("FORBIDDEN", "Cannot delete questions outside your college", status_code=403)
        elif role == "department":
            # Department admin can only delete questions in their department
            if question.get("department_id") != request_user.get("department_id"):
                return error_response("FORBIDDEN", "Cannot delete questions outside your department", status_code=403)
        elif role == "batch":
            # Batch admin can only delete questions in their batch
            if question.get("batch_id") != request_user.get("batch_id"):
                return error_response("FORBIDDEN", "Cannot delete questions outside your batch", status_code=403)
        
        try:
            QuestionModel().delete(question_id)
            audit_log(user_id, "delete_question", "question", question_id, {"title": question.get("title")})
            return success_response(None, "Question deleted successfully")
        except Exception as e:
            return error_response("DELETE_ERROR", f"Failed to delete question: {str(e)}", status_code=500)
    
    @staticmethod
    def update_question(request_user, question_id, data):
        """
        Update a question with role-based access control.
        
        Args:
            request_user (dict): Authenticated user data
            question_id (str): Question ID to update
            data (dict): Updated question data
            
        Returns:
            tuple: (response, status_code)
        """
        question = QuestionModel().get(question_id)
        if not question:
            return error_response("NOT_FOUND", "Question not found", status_code=404)
        
        role = request_user.get("role")
        
        # Check authorization based on role
        if role == "admin":
            pass
        elif role == "college":
            if question.get("college_id") != request_user.get("college_id"):
                return error_response("FORBIDDEN", "Cannot update questions outside your college", status_code=403)
        elif role == "department":
            if question.get("department_id") != request_user.get("department_id"):
                return error_response("FORBIDDEN", "Cannot update questions outside your department", status_code=403)
        elif role == "batch":
            if question.get("batch_id") != request_user.get("batch_id"):
                return error_response("FORBIDDEN", "Cannot update questions outside your batch", status_code=403)
        
        try:
            update_data = {}
            
            if "title" in data and data.get("title"):
                update_data["title"] = data.get("title").strip()
            
            if "description" in data and data.get("description"):
                update_data["description"] = data.get("description").strip()
            
            if "language" in data and data.get("language"):
                update_data["language"] = data.get("language")
            
            if "difficulty" in data and data.get("difficulty"):
                update_data["difficulty"] = data.get("difficulty")
            
            if "sample_input" in data or "sample_output" in data:
                sample_input = data.get("sample_input", question.get("sample_input", ""))
                sample_output = data.get("sample_output", question.get("sample_output", ""))
                
                update_data["sample_input"] = sample_input.strip()
                update_data["sample_output"] = sample_output.strip()
                update_data["open_testcases"] = [{
                    "input": sample_input.strip(),
                    "expected_output": sample_output.strip()
                }]
            
            if "hidden_testcases" in data and data.get("hidden_testcases"):
                update_data["hidden_testcases"] = data.get("hidden_testcases")
            
            QuestionModel().update(question_id, update_data)
            
            audit_log(
                request_user.get("uid"), "update_question", "question", question_id,
                {"title": update_data.get("title", question.get("title"))}
            )
            
            return success_response(None, "Question updated successfully")
        
        except Exception as e:
            return error_response("UPDATE_ERROR", f"Failed to update question: {str(e)}", status_code=500)
